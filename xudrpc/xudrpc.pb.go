// Code generated by protoc-gen-go. DO NOT EDIT.
// source: xudrpc.proto

/*
Package xudrpc is a generated protocol buffer package.

It is generated from these files:
	xudrpc.proto

It has these top-level messages:
	AddCurrencyRequest
	AddCurrencyResponse
	AddPairRequest
	AddPairResponse
	RemoveOrderRequest
	RemoveOrderResponse
	ChannelBalance
	ChannelBalanceRequest
	ChannelBalanceResponse
	ConnectRequest
	ConnectResponse
	BanRequest
	BanResponse
	GetInfoRequest
	GetInfoResponse
	GetOrdersRequest
	GetOrdersResponse
	ListCurrenciesRequest
	ListCurrenciesResponse
	ListPairsRequest
	ListPairsResponse
	ListPeersRequest
	ListPeersResponse
	LndChannels
	LndInfo
	Order
	OrderRemoval
	Orders
	OrdersCount
	Peer
	PlaceOrderRequest
	PlaceOrderResponse
	PlaceOrderEvent
	RaidenInfo
	RemoveCurrencyRequest
	RemoveCurrencyResponse
	RemovePairRequest
	RemovePairResponse
	ShutdownRequest
	ShutdownResponse
	SubscribeAddedOrdersRequest
	SubscribeRemovedOrdersRequest
	SubscribeSwapsRequest
	SwapResult
	UnbanRequest
	UnbanResponse
*/
package xudrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type OrderSide int32

const (
	OrderSide_BUY  OrderSide = 0
	OrderSide_SELL OrderSide = 1
)

var OrderSide_name = map[int32]string{
	0: "BUY",
	1: "SELL",
}
var OrderSide_value = map[string]int32{
	"BUY":  0,
	"SELL": 1,
}

func (x OrderSide) String() string {
	return proto.EnumName(OrderSide_name, int32(x))
}
func (OrderSide) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type AddCurrencyRequest_SwapClient int32

const (
	AddCurrencyRequest_LND    AddCurrencyRequest_SwapClient = 0
	AddCurrencyRequest_RAIDEN AddCurrencyRequest_SwapClient = 1
)

var AddCurrencyRequest_SwapClient_name = map[int32]string{
	0: "LND",
	1: "RAIDEN",
}
var AddCurrencyRequest_SwapClient_value = map[string]int32{
	"LND":    0,
	"RAIDEN": 1,
}

func (x AddCurrencyRequest_SwapClient) String() string {
	return proto.EnumName(AddCurrencyRequest_SwapClient_name, int32(x))
}
func (AddCurrencyRequest_SwapClient) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0}
}

type SwapResult_Role int32

const (
	SwapResult_TAKER SwapResult_Role = 0
	SwapResult_MAKER SwapResult_Role = 1
)

var SwapResult_Role_name = map[int32]string{
	0: "TAKER",
	1: "MAKER",
}
var SwapResult_Role_value = map[string]int32{
	"TAKER": 0,
	"MAKER": 1,
}

func (x SwapResult_Role) String() string {
	return proto.EnumName(SwapResult_Role_name, int32(x))
}
func (SwapResult_Role) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{43, 0} }

type AddCurrencyRequest struct {
	// The ticker symbol for this currency such as BTC, LTC, ETH, etc...
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
	// The payment channel network client to use for executing swaps
	SwapClient AddCurrencyRequest_SwapClient `protobuf:"varint,2,opt,name=swap_client,enum=xudrpc.AddCurrencyRequest_SwapClient" json:"swap_client,omitempty"`
	// The contract address for layered tokens such as ERC20
	TokenAddress string `protobuf:"bytes,3,opt,name=token_address" json:"token_address,omitempty"`
	// The number of places to the right of the decimal point of the smallest subunit of the currency. For example, BTC, LTC, and others
	// where the smallest subunits (satoshis) are 0.00000001 full units (bitcoins) have 8 decimal places. ETH has 18. This can be thought
	// of as the base 10 exponent of the smallest subunit expressed as a positive integer. A default value of 8 is used if unspecified.
	DecimalPlaces uint32 `protobuf:"varint,4,opt,name=decimal_places" json:"decimal_places,omitempty"`
}

func (m *AddCurrencyRequest) Reset()                    { *m = AddCurrencyRequest{} }
func (m *AddCurrencyRequest) String() string            { return proto.CompactTextString(m) }
func (*AddCurrencyRequest) ProtoMessage()               {}
func (*AddCurrencyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AddCurrencyRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *AddCurrencyRequest) GetSwapClient() AddCurrencyRequest_SwapClient {
	if m != nil {
		return m.SwapClient
	}
	return AddCurrencyRequest_LND
}

func (m *AddCurrencyRequest) GetTokenAddress() string {
	if m != nil {
		return m.TokenAddress
	}
	return ""
}

func (m *AddCurrencyRequest) GetDecimalPlaces() uint32 {
	if m != nil {
		return m.DecimalPlaces
	}
	return 0
}

type AddCurrencyResponse struct {
}

func (m *AddCurrencyResponse) Reset()                    { *m = AddCurrencyResponse{} }
func (m *AddCurrencyResponse) String() string            { return proto.CompactTextString(m) }
func (*AddCurrencyResponse) ProtoMessage()               {}
func (*AddCurrencyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type AddPairRequest struct {
	// The base currency that is bought and sold for this trading pair
	BaseCurrency string `protobuf:"bytes,1,opt,name=base_currency" json:"base_currency,omitempty"`
	// The currency used to quote a price for the base currency
	QuoteCurrency string `protobuf:"bytes,2,opt,name=quote_currency" json:"quote_currency,omitempty"`
}

func (m *AddPairRequest) Reset()                    { *m = AddPairRequest{} }
func (m *AddPairRequest) String() string            { return proto.CompactTextString(m) }
func (*AddPairRequest) ProtoMessage()               {}
func (*AddPairRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AddPairRequest) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *AddPairRequest) GetQuoteCurrency() string {
	if m != nil {
		return m.QuoteCurrency
	}
	return ""
}

type AddPairResponse struct {
}

func (m *AddPairResponse) Reset()                    { *m = AddPairResponse{} }
func (m *AddPairResponse) String() string            { return proto.CompactTextString(m) }
func (*AddPairResponse) ProtoMessage()               {}
func (*AddPairResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type RemoveOrderRequest struct {
	// The local id of the order to remove
	OrderId string `protobuf:"bytes,1,opt,name=order_id" json:"order_id,omitempty"`
}

func (m *RemoveOrderRequest) Reset()                    { *m = RemoveOrderRequest{} }
func (m *RemoveOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveOrderRequest) ProtoMessage()               {}
func (*RemoveOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RemoveOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

type RemoveOrderResponse struct {
}

func (m *RemoveOrderResponse) Reset()                    { *m = RemoveOrderResponse{} }
func (m *RemoveOrderResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveOrderResponse) ProtoMessage()               {}
func (*RemoveOrderResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type ChannelBalance struct {
	// Sum of channels balances denominated in satoshis or equivalent
	Balance int64 `protobuf:"varint,1,opt,name=balance" json:"balance,omitempty"`
	// Sum of channels pending balances denominated in satoshis or equivalent
	PendingOpenBalance int64 `protobuf:"varint,2,opt,name=pending_open_balance" json:"pending_open_balance,omitempty"`
}

func (m *ChannelBalance) Reset()                    { *m = ChannelBalance{} }
func (m *ChannelBalance) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalance) ProtoMessage()               {}
func (*ChannelBalance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ChannelBalance) GetBalance() int64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *ChannelBalance) GetPendingOpenBalance() int64 {
	if m != nil {
		return m.PendingOpenBalance
	}
	return 0
}

type ChannelBalanceRequest struct {
	// The ticker symbol of the currency to query for, if unspecified then balances for all
	// supported currencies are queried
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
}

func (m *ChannelBalanceRequest) Reset()                    { *m = ChannelBalanceRequest{} }
func (m *ChannelBalanceRequest) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalanceRequest) ProtoMessage()               {}
func (*ChannelBalanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ChannelBalanceRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type ChannelBalanceResponse struct {
	// A map between currency ticker symbols and their channel balances
	Balances map[string]*ChannelBalance `protobuf:"bytes,1,rep,name=balances,json=orders" json:"balances,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ChannelBalanceResponse) Reset()                    { *m = ChannelBalanceResponse{} }
func (m *ChannelBalanceResponse) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalanceResponse) ProtoMessage()               {}
func (*ChannelBalanceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ChannelBalanceResponse) GetBalances() map[string]*ChannelBalance {
	if m != nil {
		return m.Balances
	}
	return nil
}

type ConnectRequest struct {
	NodeUri string `protobuf:"bytes,1,opt,name=node_uri" json:"node_uri,omitempty"`
}

func (m *ConnectRequest) Reset()                    { *m = ConnectRequest{} }
func (m *ConnectRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectRequest) ProtoMessage()               {}
func (*ConnectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ConnectRequest) GetNodeUri() string {
	if m != nil {
		return m.NodeUri
	}
	return ""
}

type ConnectResponse struct {
}

func (m *ConnectResponse) Reset()                    { *m = ConnectResponse{} }
func (m *ConnectResponse) String() string            { return proto.CompactTextString(m) }
func (*ConnectResponse) ProtoMessage()               {}
func (*ConnectResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type BanRequest struct {
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
}

func (m *BanRequest) Reset()                    { *m = BanRequest{} }
func (m *BanRequest) String() string            { return proto.CompactTextString(m) }
func (*BanRequest) ProtoMessage()               {}
func (*BanRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *BanRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

type BanResponse struct {
}

func (m *BanResponse) Reset()                    { *m = BanResponse{} }
func (m *BanResponse) String() string            { return proto.CompactTextString(m) }
func (*BanResponse) ProtoMessage()               {}
func (*BanResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type GetInfoRequest struct {
}

func (m *GetInfoRequest) Reset()                    { *m = GetInfoRequest{} }
func (m *GetInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInfoRequest) ProtoMessage()               {}
func (*GetInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type GetInfoResponse struct {
	Version    string       `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	NodePubKey string       `protobuf:"bytes,2,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
	Uris       []string     `protobuf:"bytes,3,rep,name=uris" json:"uris,omitempty"`
	NumPeers   int32        `protobuf:"varint,4,opt,name=num_peers" json:"num_peers,omitempty"`
	NumPairs   int32        `protobuf:"varint,5,opt,name=num_pairs" json:"num_pairs,omitempty"`
	Orders     *OrdersCount `protobuf:"bytes,6,opt,name=orders" json:"orders,omitempty"`
	Lndbtc     *LndInfo     `protobuf:"bytes,7,opt,name=lndbtc" json:"lndbtc,omitempty"`
	Lndltc     *LndInfo     `protobuf:"bytes,8,opt,name=lndltc" json:"lndltc,omitempty"`
	Raiden     *RaidenInfo  `protobuf:"bytes,9,opt,name=raiden" json:"raiden,omitempty"`
}

func (m *GetInfoResponse) Reset()                    { *m = GetInfoResponse{} }
func (m *GetInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInfoResponse) ProtoMessage()               {}
func (*GetInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GetInfoResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *GetInfoResponse) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *GetInfoResponse) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *GetInfoResponse) GetNumPeers() int32 {
	if m != nil {
		return m.NumPeers
	}
	return 0
}

func (m *GetInfoResponse) GetNumPairs() int32 {
	if m != nil {
		return m.NumPairs
	}
	return 0
}

func (m *GetInfoResponse) GetOrders() *OrdersCount {
	if m != nil {
		return m.Orders
	}
	return nil
}

func (m *GetInfoResponse) GetLndbtc() *LndInfo {
	if m != nil {
		return m.Lndbtc
	}
	return nil
}

func (m *GetInfoResponse) GetLndltc() *LndInfo {
	if m != nil {
		return m.Lndltc
	}
	return nil
}

func (m *GetInfoResponse) GetRaiden() *RaidenInfo {
	if m != nil {
		return m.Raiden
	}
	return nil
}

type GetOrdersRequest struct {
	// The trading pair for which to retrieve orders
	PairId string `protobuf:"bytes,1,opt,name=pair_id" json:"pair_id,omitempty"`
	// Whether own orders should be included in result or not
	IncludeOwnOrders bool `protobuf:"varint,2,opt,name=include_own_orders" json:"include_own_orders,omitempty"`
}

func (m *GetOrdersRequest) Reset()                    { *m = GetOrdersRequest{} }
func (m *GetOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*GetOrdersRequest) ProtoMessage()               {}
func (*GetOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetOrdersRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *GetOrdersRequest) GetIncludeOwnOrders() bool {
	if m != nil {
		return m.IncludeOwnOrders
	}
	return false
}

type GetOrdersResponse struct {
	// A map between pair ids and their buy and sell orders
	Orders map[string]*Orders `protobuf:"bytes,1,rep,name=orders" json:"orders,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *GetOrdersResponse) Reset()                    { *m = GetOrdersResponse{} }
func (m *GetOrdersResponse) String() string            { return proto.CompactTextString(m) }
func (*GetOrdersResponse) ProtoMessage()               {}
func (*GetOrdersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GetOrdersResponse) GetOrders() map[string]*Orders {
	if m != nil {
		return m.Orders
	}
	return nil
}

type ListCurrenciesRequest struct {
}

func (m *ListCurrenciesRequest) Reset()                    { *m = ListCurrenciesRequest{} }
func (m *ListCurrenciesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListCurrenciesRequest) ProtoMessage()               {}
func (*ListCurrenciesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

type ListCurrenciesResponse struct {
	// The ticker symbols of supported currencies
	Currencies []string `protobuf:"bytes,1,rep,name=currencies" json:"currencies,omitempty"`
}

func (m *ListCurrenciesResponse) Reset()                    { *m = ListCurrenciesResponse{} }
func (m *ListCurrenciesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListCurrenciesResponse) ProtoMessage()               {}
func (*ListCurrenciesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ListCurrenciesResponse) GetCurrencies() []string {
	if m != nil {
		return m.Currencies
	}
	return nil
}

type ListPairsRequest struct {
}

func (m *ListPairsRequest) Reset()                    { *m = ListPairsRequest{} }
func (m *ListPairsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPairsRequest) ProtoMessage()               {}
func (*ListPairsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

type ListPairsResponse struct {
	// The supported trading pair tickers in formats like "LTC/BTC"
	Pairs []string `protobuf:"bytes,1,rep,name=pairs" json:"pairs,omitempty"`
}

func (m *ListPairsResponse) Reset()                    { *m = ListPairsResponse{} }
func (m *ListPairsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPairsResponse) ProtoMessage()               {}
func (*ListPairsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *ListPairsResponse) GetPairs() []string {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type ListPeersRequest struct {
}

func (m *ListPeersRequest) Reset()                    { *m = ListPeersRequest{} }
func (m *ListPeersRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPeersRequest) ProtoMessage()               {}
func (*ListPeersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

type ListPeersResponse struct {
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *ListPeersResponse) Reset()                    { *m = ListPeersResponse{} }
func (m *ListPeersResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPeersResponse) ProtoMessage()               {}
func (*ListPeersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *ListPeersResponse) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type LndChannels struct {
	Active   int32 `protobuf:"varint,1,opt,name=active" json:"active,omitempty"`
	Inactive int32 `protobuf:"varint,2,opt,name=inactive" json:"inactive,omitempty"`
	Pending  int32 `protobuf:"varint,3,opt,name=pending" json:"pending,omitempty"`
}

func (m *LndChannels) Reset()                    { *m = LndChannels{} }
func (m *LndChannels) String() string            { return proto.CompactTextString(m) }
func (*LndChannels) ProtoMessage()               {}
func (*LndChannels) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *LndChannels) GetActive() int32 {
	if m != nil {
		return m.Active
	}
	return 0
}

func (m *LndChannels) GetInactive() int32 {
	if m != nil {
		return m.Inactive
	}
	return 0
}

func (m *LndChannels) GetPending() int32 {
	if m != nil {
		return m.Pending
	}
	return 0
}

type LndInfo struct {
	Error       string       `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Channels    *LndChannels `protobuf:"bytes,2,opt,name=channels" json:"channels,omitempty"`
	Chains      []string     `protobuf:"bytes,3,rep,name=chains" json:"chains,omitempty"`
	Blockheight int32        `protobuf:"varint,4,opt,name=blockheight" json:"blockheight,omitempty"`
	Uris        []string     `protobuf:"bytes,5,rep,name=uris" json:"uris,omitempty"`
	Version     string       `protobuf:"bytes,6,opt,name=version" json:"version,omitempty"`
	Alias       string       `protobuf:"bytes,7,opt,name=alias" json:"alias,omitempty"`
}

func (m *LndInfo) Reset()                    { *m = LndInfo{} }
func (m *LndInfo) String() string            { return proto.CompactTextString(m) }
func (*LndInfo) ProtoMessage()               {}
func (*LndInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *LndInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *LndInfo) GetChannels() *LndChannels {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *LndInfo) GetChains() []string {
	if m != nil {
		return m.Chains
	}
	return nil
}

func (m *LndInfo) GetBlockheight() int32 {
	if m != nil {
		return m.Blockheight
	}
	return 0
}

func (m *LndInfo) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *LndInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *LndInfo) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type Order struct {
	// The price of the order.
	Price float64 `protobuf:"fixed64,1,opt,name=price" json:"price,omitempty"`
	// The quantity of the order.
	Quantity float64 `protobuf:"fixed64,2,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair that this order is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id" json:"pair_id,omitempty"`
	// A UUID for this order.
	Id string `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
	// Types that are valid to be assigned to OwnOrPeer:
	//	*Order_PeerPubKey
	//	*Order_LocalId
	OwnOrPeer isOrder_OwnOrPeer `protobuf_oneof:"own_or_peer"`
	// The epoch time when this order was created.
	CreatedAt int64 `protobuf:"varint,7,opt,name=created_at" json:"created_at,omitempty"`
	// Whether this order is a buy or sell
	Side OrderSide `protobuf:"varint,8,opt,name=side,enum=xudrpc.OrderSide" json:"side,omitempty"`
	// Whether this order is a local own order or a remote peer order.
	IsOwnOrder bool `protobuf:"varint,9,opt,name=is_own_order" json:"is_own_order,omitempty"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

type isOrder_OwnOrPeer interface{ isOrder_OwnOrPeer() }

type Order_PeerPubKey struct {
	PeerPubKey string `protobuf:"bytes,5,opt,name=peer_pub_key,oneof"`
}
type Order_LocalId struct {
	LocalId string `protobuf:"bytes,6,opt,name=local_id,oneof"`
}

func (*Order_PeerPubKey) isOrder_OwnOrPeer() {}
func (*Order_LocalId) isOrder_OwnOrPeer()    {}

func (m *Order) GetOwnOrPeer() isOrder_OwnOrPeer {
	if m != nil {
		return m.OwnOrPeer
	}
	return nil
}

func (m *Order) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Order) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Order) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *Order) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Order) GetPeerPubKey() string {
	if x, ok := m.GetOwnOrPeer().(*Order_PeerPubKey); ok {
		return x.PeerPubKey
	}
	return ""
}

func (m *Order) GetLocalId() string {
	if x, ok := m.GetOwnOrPeer().(*Order_LocalId); ok {
		return x.LocalId
	}
	return ""
}

func (m *Order) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_BUY
}

func (m *Order) GetIsOwnOrder() bool {
	if m != nil {
		return m.IsOwnOrder
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Order) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Order_OneofMarshaler, _Order_OneofUnmarshaler, _Order_OneofSizer, []interface{}{
		(*Order_PeerPubKey)(nil),
		(*Order_LocalId)(nil),
	}
}

func _Order_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Order)
	// own_or_peer
	switch x := m.OwnOrPeer.(type) {
	case *Order_PeerPubKey:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.PeerPubKey)
	case *Order_LocalId:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.LocalId)
	case nil:
	default:
		return fmt.Errorf("Order.OwnOrPeer has unexpected type %T", x)
	}
	return nil
}

func _Order_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Order)
	switch tag {
	case 5: // own_or_peer.peer_pub_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.OwnOrPeer = &Order_PeerPubKey{x}
		return true, err
	case 6: // own_or_peer.local_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.OwnOrPeer = &Order_LocalId{x}
		return true, err
	default:
		return false, nil
	}
}

func _Order_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Order)
	// own_or_peer
	switch x := m.OwnOrPeer.(type) {
	case *Order_PeerPubKey:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PeerPubKey)))
		n += len(x.PeerPubKey)
	case *Order_LocalId:
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.LocalId)))
		n += len(x.LocalId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OrderRemoval struct {
	// The quantity of the order being removed.
	Quantity float64 `protobuf:"fixed64,1,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair that the order is for.
	PairId string `protobuf:"bytes,2,opt,name=pair_id" json:"pair_id,omitempty"`
	// The global UUID for the order.
	OrderId string `protobuf:"bytes,3,opt,name=order_id" json:"order_id,omitempty"`
	// The local id for the order, if applicable.
	LocalId string `protobuf:"bytes,4,opt,name=local_id" json:"local_id,omitempty"`
	// Whether the order being removed is a local own order or a remote peer order.
	IsOwnOrder bool `protobuf:"varint,5,opt,name=is_own_order" json:"is_own_order,omitempty"`
}

func (m *OrderRemoval) Reset()                    { *m = OrderRemoval{} }
func (m *OrderRemoval) String() string            { return proto.CompactTextString(m) }
func (*OrderRemoval) ProtoMessage()               {}
func (*OrderRemoval) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *OrderRemoval) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *OrderRemoval) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *OrderRemoval) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *OrderRemoval) GetLocalId() string {
	if m != nil {
		return m.LocalId
	}
	return ""
}

func (m *OrderRemoval) GetIsOwnOrder() bool {
	if m != nil {
		return m.IsOwnOrder
	}
	return false
}

type Orders struct {
	// A list of buy orders sorted by descending price
	BuyOrders []*Order `protobuf:"bytes,1,rep,name=buy_orders" json:"buy_orders,omitempty"`
	// A list of sell orders sorted by ascending price
	SellOrders []*Order `protobuf:"bytes,2,rep,name=sell_orders" json:"sell_orders,omitempty"`
}

func (m *Orders) Reset()                    { *m = Orders{} }
func (m *Orders) String() string            { return proto.CompactTextString(m) }
func (*Orders) ProtoMessage()               {}
func (*Orders) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *Orders) GetBuyOrders() []*Order {
	if m != nil {
		return m.BuyOrders
	}
	return nil
}

func (m *Orders) GetSellOrders() []*Order {
	if m != nil {
		return m.SellOrders
	}
	return nil
}

type OrdersCount struct {
	Peer int32 `protobuf:"varint,1,opt,name=peer" json:"peer,omitempty"`
	Own  int32 `protobuf:"varint,2,opt,name=own" json:"own,omitempty"`
}

func (m *OrdersCount) Reset()                    { *m = OrdersCount{} }
func (m *OrdersCount) String() string            { return proto.CompactTextString(m) }
func (*OrdersCount) ProtoMessage()               {}
func (*OrdersCount) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *OrdersCount) GetPeer() int32 {
	if m != nil {
		return m.Peer
	}
	return 0
}

func (m *OrdersCount) GetOwn() int32 {
	if m != nil {
		return m.Own
	}
	return 0
}

type Peer struct {
	// The socket address with host and port for this peer
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// The node pub key to uniquely identify this peer
	NodePubKey string `protobuf:"bytes,2,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
	// The lnd BTC pub key associated with this peer
	LndBtcPubKey string `protobuf:"bytes,3,opt,name=lnd_btc_pub_key" json:"lnd_btc_pub_key,omitempty"`
	// The lnd LTC pub key associated with this peer
	LndLtcPubKey string `protobuf:"bytes,4,opt,name=lnd_ltc_pub_key" json:"lnd_ltc_pub_key,omitempty"`
	// Indicates whether this peer was connected inbound
	Inbound bool `protobuf:"varint,5,opt,name=inbound" json:"inbound,omitempty"`
	// A list of trading pair tickers supported by this peer
	Pairs []string `protobuf:"bytes,6,rep,name=pairs" json:"pairs,omitempty"`
	// The version of xud being used by the peer
	XudVersion string `protobuf:"bytes,7,opt,name=xud_version" json:"xud_version,omitempty"`
	// The time in seconds that we have been connected to this peer
	SecondsConnected int32 `protobuf:"varint,8,opt,name=seconds_connected" json:"seconds_connected,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *Peer) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Peer) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *Peer) GetLndBtcPubKey() string {
	if m != nil {
		return m.LndBtcPubKey
	}
	return ""
}

func (m *Peer) GetLndLtcPubKey() string {
	if m != nil {
		return m.LndLtcPubKey
	}
	return ""
}

func (m *Peer) GetInbound() bool {
	if m != nil {
		return m.Inbound
	}
	return false
}

func (m *Peer) GetPairs() []string {
	if m != nil {
		return m.Pairs
	}
	return nil
}

func (m *Peer) GetXudVersion() string {
	if m != nil {
		return m.XudVersion
	}
	return ""
}

func (m *Peer) GetSecondsConnected() int32 {
	if m != nil {
		return m.SecondsConnected
	}
	return 0
}

type PlaceOrderRequest struct {
	// The price of the order.
	Price float64 `protobuf:"fixed64,1,opt,name=price" json:"price,omitempty"`
	// The quantity of the order.
	Quantity float64 `protobuf:"fixed64,2,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair that the order is for
	PairId string `protobuf:"bytes,3,opt,name=pair_id" json:"pair_id,omitempty"`
	// The local id to assign to the order
	OrderId string `protobuf:"bytes,4,opt,name=order_id" json:"order_id,omitempty"`
	// Whether the order is a Buy or Sell
	Side OrderSide `protobuf:"varint,5,opt,name=side,enum=xudrpc.OrderSide" json:"side,omitempty"`
}

func (m *PlaceOrderRequest) Reset()                    { *m = PlaceOrderRequest{} }
func (m *PlaceOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*PlaceOrderRequest) ProtoMessage()               {}
func (*PlaceOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *PlaceOrderRequest) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *PlaceOrderRequest) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *PlaceOrderRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *PlaceOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *PlaceOrderRequest) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_BUY
}

type PlaceOrderResponse struct {
	// A list of own orders (or portions thereof) that matched the newly placed order
	InternalMatches []*Order `protobuf:"bytes,1,rep,name=internal_matches" json:"internal_matches,omitempty"`
	// A list of swap results of peer orders that matched the newly placed order
	SwapResults []*SwapResult `protobuf:"bytes,2,rep,name=swap_results" json:"swap_results,omitempty"`
	// The remaining portion of the order, after matches, that enters the order book
	RemainingOrder *Order `protobuf:"bytes,3,opt,name=remaining_order" json:"remaining_order,omitempty"`
}

func (m *PlaceOrderResponse) Reset()                    { *m = PlaceOrderResponse{} }
func (m *PlaceOrderResponse) String() string            { return proto.CompactTextString(m) }
func (*PlaceOrderResponse) ProtoMessage()               {}
func (*PlaceOrderResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *PlaceOrderResponse) GetInternalMatches() []*Order {
	if m != nil {
		return m.InternalMatches
	}
	return nil
}

func (m *PlaceOrderResponse) GetSwapResults() []*SwapResult {
	if m != nil {
		return m.SwapResults
	}
	return nil
}

func (m *PlaceOrderResponse) GetRemainingOrder() *Order {
	if m != nil {
		return m.RemainingOrder
	}
	return nil
}

type PlaceOrderEvent struct {
	// Types that are valid to be assigned to Event:
	//	*PlaceOrderEvent_InternalMatch
	//	*PlaceOrderEvent_SwapResult
	//	*PlaceOrderEvent_RemainingOrder
	Event isPlaceOrderEvent_Event `protobuf_oneof:"event"`
}

func (m *PlaceOrderEvent) Reset()                    { *m = PlaceOrderEvent{} }
func (m *PlaceOrderEvent) String() string            { return proto.CompactTextString(m) }
func (*PlaceOrderEvent) ProtoMessage()               {}
func (*PlaceOrderEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

type isPlaceOrderEvent_Event interface{ isPlaceOrderEvent_Event() }

type PlaceOrderEvent_InternalMatch struct {
	InternalMatch *Order `protobuf:"bytes,1,opt,name=internal_match,oneof"`
}
type PlaceOrderEvent_SwapResult struct {
	SwapResult *SwapResult `protobuf:"bytes,2,opt,name=swap_result,oneof"`
}
type PlaceOrderEvent_RemainingOrder struct {
	RemainingOrder *Order `protobuf:"bytes,3,opt,name=remaining_order,oneof"`
}

func (*PlaceOrderEvent_InternalMatch) isPlaceOrderEvent_Event()  {}
func (*PlaceOrderEvent_SwapResult) isPlaceOrderEvent_Event()     {}
func (*PlaceOrderEvent_RemainingOrder) isPlaceOrderEvent_Event() {}

func (m *PlaceOrderEvent) GetEvent() isPlaceOrderEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *PlaceOrderEvent) GetInternalMatch() *Order {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_InternalMatch); ok {
		return x.InternalMatch
	}
	return nil
}

func (m *PlaceOrderEvent) GetSwapResult() *SwapResult {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_SwapResult); ok {
		return x.SwapResult
	}
	return nil
}

func (m *PlaceOrderEvent) GetRemainingOrder() *Order {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_RemainingOrder); ok {
		return x.RemainingOrder
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PlaceOrderEvent) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PlaceOrderEvent_OneofMarshaler, _PlaceOrderEvent_OneofUnmarshaler, _PlaceOrderEvent_OneofSizer, []interface{}{
		(*PlaceOrderEvent_InternalMatch)(nil),
		(*PlaceOrderEvent_SwapResult)(nil),
		(*PlaceOrderEvent_RemainingOrder)(nil),
	}
}

func _PlaceOrderEvent_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PlaceOrderEvent)
	// event
	switch x := m.Event.(type) {
	case *PlaceOrderEvent_InternalMatch:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InternalMatch); err != nil {
			return err
		}
	case *PlaceOrderEvent_SwapResult:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SwapResult); err != nil {
			return err
		}
	case *PlaceOrderEvent_RemainingOrder:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RemainingOrder); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PlaceOrderEvent.Event has unexpected type %T", x)
	}
	return nil
}

func _PlaceOrderEvent_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PlaceOrderEvent)
	switch tag {
	case 1: // event.internal_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Order)
		err := b.DecodeMessage(msg)
		m.Event = &PlaceOrderEvent_InternalMatch{msg}
		return true, err
	case 2: // event.swap_result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SwapResult)
		err := b.DecodeMessage(msg)
		m.Event = &PlaceOrderEvent_SwapResult{msg}
		return true, err
	case 3: // event.remaining_order
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Order)
		err := b.DecodeMessage(msg)
		m.Event = &PlaceOrderEvent_RemainingOrder{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PlaceOrderEvent_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PlaceOrderEvent)
	// event
	switch x := m.Event.(type) {
	case *PlaceOrderEvent_InternalMatch:
		s := proto.Size(x.InternalMatch)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PlaceOrderEvent_SwapResult:
		s := proto.Size(x.SwapResult)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PlaceOrderEvent_RemainingOrder:
		s := proto.Size(x.RemainingOrder)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RaidenInfo struct {
	Error    string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Address  string `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
	Channels int32  `protobuf:"varint,3,opt,name=channels" json:"channels,omitempty"`
	Version  string `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
}

func (m *RaidenInfo) Reset()                    { *m = RaidenInfo{} }
func (m *RaidenInfo) String() string            { return proto.CompactTextString(m) }
func (*RaidenInfo) ProtoMessage()               {}
func (*RaidenInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *RaidenInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *RaidenInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RaidenInfo) GetChannels() int32 {
	if m != nil {
		return m.Channels
	}
	return 0
}

func (m *RaidenInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type RemoveCurrencyRequest struct {
	// The ticker symbol for this currency such as BTC, LTC, ETH, etc...
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
}

func (m *RemoveCurrencyRequest) Reset()                    { *m = RemoveCurrencyRequest{} }
func (m *RemoveCurrencyRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveCurrencyRequest) ProtoMessage()               {}
func (*RemoveCurrencyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *RemoveCurrencyRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type RemoveCurrencyResponse struct {
}

func (m *RemoveCurrencyResponse) Reset()                    { *m = RemoveCurrencyResponse{} }
func (m *RemoveCurrencyResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveCurrencyResponse) ProtoMessage()               {}
func (*RemoveCurrencyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

type RemovePairRequest struct {
	// The trading pair ticker to remove, such as "LTC/BTC"
	PairId string `protobuf:"bytes,1,opt,name=pair_id" json:"pair_id,omitempty"`
}

func (m *RemovePairRequest) Reset()                    { *m = RemovePairRequest{} }
func (m *RemovePairRequest) String() string            { return proto.CompactTextString(m) }
func (*RemovePairRequest) ProtoMessage()               {}
func (*RemovePairRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *RemovePairRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

type RemovePairResponse struct {
}

func (m *RemovePairResponse) Reset()                    { *m = RemovePairResponse{} }
func (m *RemovePairResponse) String() string            { return proto.CompactTextString(m) }
func (*RemovePairResponse) ProtoMessage()               {}
func (*RemovePairResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

type ShutdownRequest struct {
}

func (m *ShutdownRequest) Reset()                    { *m = ShutdownRequest{} }
func (m *ShutdownRequest) String() string            { return proto.CompactTextString(m) }
func (*ShutdownRequest) ProtoMessage()               {}
func (*ShutdownRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

type ShutdownResponse struct {
}

func (m *ShutdownResponse) Reset()                    { *m = ShutdownResponse{} }
func (m *ShutdownResponse) String() string            { return proto.CompactTextString(m) }
func (*ShutdownResponse) ProtoMessage()               {}
func (*ShutdownResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

type SubscribeAddedOrdersRequest struct {
}

func (m *SubscribeAddedOrdersRequest) Reset()                    { *m = SubscribeAddedOrdersRequest{} }
func (m *SubscribeAddedOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeAddedOrdersRequest) ProtoMessage()               {}
func (*SubscribeAddedOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

type SubscribeRemovedOrdersRequest struct {
}

func (m *SubscribeRemovedOrdersRequest) Reset()                    { *m = SubscribeRemovedOrdersRequest{} }
func (m *SubscribeRemovedOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeRemovedOrdersRequest) ProtoMessage()               {}
func (*SubscribeRemovedOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

type SubscribeSwapsRequest struct {
}

func (m *SubscribeSwapsRequest) Reset()                    { *m = SubscribeSwapsRequest{} }
func (m *SubscribeSwapsRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeSwapsRequest) ProtoMessage()               {}
func (*SubscribeSwapsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

type SwapResult struct {
	// The global UUID for the order that was swapped.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId" json:"order_id,omitempty"`
	// The local id for the order that was swapped.
	LocalId string `protobuf:"bytes,2,opt,name=local_id" json:"local_id,omitempty"`
	// The trading pair that this order is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id" json:"pair_id,omitempty"`
	// The order quantity that was swapped.
	Quantity float64 `protobuf:"fixed64,4,opt,name=quantity" json:"quantity,omitempty"`
	// The hex-encoded r_hash for the swap payments.
	RHash string `protobuf:"bytes,5,opt,name=r_hash" json:"r_hash,omitempty"`
	// The amount of subunits (satoshis) received.
	AmountReceived int64 `protobuf:"varint,6,opt,name=amount_received" json:"amount_received,omitempty"`
	// The amount of subunits (satoshis) sent.
	AmountSent int64 `protobuf:"varint,7,opt,name=amount_sent" json:"amount_sent,omitempty"`
	// The node pub key of the peer that executed this order.
	PeerPubKey string `protobuf:"bytes,8,opt,name=peer_pub_key" json:"peer_pub_key,omitempty"`
	// Our role in the swap, either MAKER or TAKER
	Role SwapResult_Role `protobuf:"varint,9,opt,name=role,enum=xudrpc.SwapResult_Role" json:"role,omitempty"`
}

func (m *SwapResult) Reset()                    { *m = SwapResult{} }
func (m *SwapResult) String() string            { return proto.CompactTextString(m) }
func (*SwapResult) ProtoMessage()               {}
func (*SwapResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *SwapResult) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SwapResult) GetLocalId() string {
	if m != nil {
		return m.LocalId
	}
	return ""
}

func (m *SwapResult) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *SwapResult) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *SwapResult) GetRHash() string {
	if m != nil {
		return m.RHash
	}
	return ""
}

func (m *SwapResult) GetAmountReceived() int64 {
	if m != nil {
		return m.AmountReceived
	}
	return 0
}

func (m *SwapResult) GetAmountSent() int64 {
	if m != nil {
		return m.AmountSent
	}
	return 0
}

func (m *SwapResult) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

func (m *SwapResult) GetRole() SwapResult_Role {
	if m != nil {
		return m.Role
	}
	return SwapResult_TAKER
}

type UnbanRequest struct {
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
	Reconnect  bool   `protobuf:"varint,2,opt,name=reconnect" json:"reconnect,omitempty"`
}

func (m *UnbanRequest) Reset()                    { *m = UnbanRequest{} }
func (m *UnbanRequest) String() string            { return proto.CompactTextString(m) }
func (*UnbanRequest) ProtoMessage()               {}
func (*UnbanRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *UnbanRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *UnbanRequest) GetReconnect() bool {
	if m != nil {
		return m.Reconnect
	}
	return false
}

type UnbanResponse struct {
}

func (m *UnbanResponse) Reset()                    { *m = UnbanResponse{} }
func (m *UnbanResponse) String() string            { return proto.CompactTextString(m) }
func (*UnbanResponse) ProtoMessage()               {}
func (*UnbanResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func init() {
	proto.RegisterType((*AddCurrencyRequest)(nil), "xudrpc.AddCurrencyRequest")
	proto.RegisterType((*AddCurrencyResponse)(nil), "xudrpc.AddCurrencyResponse")
	proto.RegisterType((*AddPairRequest)(nil), "xudrpc.AddPairRequest")
	proto.RegisterType((*AddPairResponse)(nil), "xudrpc.AddPairResponse")
	proto.RegisterType((*RemoveOrderRequest)(nil), "xudrpc.RemoveOrderRequest")
	proto.RegisterType((*RemoveOrderResponse)(nil), "xudrpc.RemoveOrderResponse")
	proto.RegisterType((*ChannelBalance)(nil), "xudrpc.ChannelBalance")
	proto.RegisterType((*ChannelBalanceRequest)(nil), "xudrpc.ChannelBalanceRequest")
	proto.RegisterType((*ChannelBalanceResponse)(nil), "xudrpc.ChannelBalanceResponse")
	proto.RegisterType((*ConnectRequest)(nil), "xudrpc.ConnectRequest")
	proto.RegisterType((*ConnectResponse)(nil), "xudrpc.ConnectResponse")
	proto.RegisterType((*BanRequest)(nil), "xudrpc.BanRequest")
	proto.RegisterType((*BanResponse)(nil), "xudrpc.BanResponse")
	proto.RegisterType((*GetInfoRequest)(nil), "xudrpc.GetInfoRequest")
	proto.RegisterType((*GetInfoResponse)(nil), "xudrpc.GetInfoResponse")
	proto.RegisterType((*GetOrdersRequest)(nil), "xudrpc.GetOrdersRequest")
	proto.RegisterType((*GetOrdersResponse)(nil), "xudrpc.GetOrdersResponse")
	proto.RegisterType((*ListCurrenciesRequest)(nil), "xudrpc.ListCurrenciesRequest")
	proto.RegisterType((*ListCurrenciesResponse)(nil), "xudrpc.ListCurrenciesResponse")
	proto.RegisterType((*ListPairsRequest)(nil), "xudrpc.ListPairsRequest")
	proto.RegisterType((*ListPairsResponse)(nil), "xudrpc.ListPairsResponse")
	proto.RegisterType((*ListPeersRequest)(nil), "xudrpc.ListPeersRequest")
	proto.RegisterType((*ListPeersResponse)(nil), "xudrpc.ListPeersResponse")
	proto.RegisterType((*LndChannels)(nil), "xudrpc.LndChannels")
	proto.RegisterType((*LndInfo)(nil), "xudrpc.LndInfo")
	proto.RegisterType((*Order)(nil), "xudrpc.Order")
	proto.RegisterType((*OrderRemoval)(nil), "xudrpc.OrderRemoval")
	proto.RegisterType((*Orders)(nil), "xudrpc.Orders")
	proto.RegisterType((*OrdersCount)(nil), "xudrpc.OrdersCount")
	proto.RegisterType((*Peer)(nil), "xudrpc.Peer")
	proto.RegisterType((*PlaceOrderRequest)(nil), "xudrpc.PlaceOrderRequest")
	proto.RegisterType((*PlaceOrderResponse)(nil), "xudrpc.PlaceOrderResponse")
	proto.RegisterType((*PlaceOrderEvent)(nil), "xudrpc.PlaceOrderEvent")
	proto.RegisterType((*RaidenInfo)(nil), "xudrpc.RaidenInfo")
	proto.RegisterType((*RemoveCurrencyRequest)(nil), "xudrpc.RemoveCurrencyRequest")
	proto.RegisterType((*RemoveCurrencyResponse)(nil), "xudrpc.RemoveCurrencyResponse")
	proto.RegisterType((*RemovePairRequest)(nil), "xudrpc.RemovePairRequest")
	proto.RegisterType((*RemovePairResponse)(nil), "xudrpc.RemovePairResponse")
	proto.RegisterType((*ShutdownRequest)(nil), "xudrpc.ShutdownRequest")
	proto.RegisterType((*ShutdownResponse)(nil), "xudrpc.ShutdownResponse")
	proto.RegisterType((*SubscribeAddedOrdersRequest)(nil), "xudrpc.SubscribeAddedOrdersRequest")
	proto.RegisterType((*SubscribeRemovedOrdersRequest)(nil), "xudrpc.SubscribeRemovedOrdersRequest")
	proto.RegisterType((*SubscribeSwapsRequest)(nil), "xudrpc.SubscribeSwapsRequest")
	proto.RegisterType((*SwapResult)(nil), "xudrpc.SwapResult")
	proto.RegisterType((*UnbanRequest)(nil), "xudrpc.UnbanRequest")
	proto.RegisterType((*UnbanResponse)(nil), "xudrpc.UnbanResponse")
	proto.RegisterEnum("xudrpc.OrderSide", OrderSide_name, OrderSide_value)
	proto.RegisterEnum("xudrpc.AddCurrencyRequest_SwapClient", AddCurrencyRequest_SwapClient_name, AddCurrencyRequest_SwapClient_value)
	proto.RegisterEnum("xudrpc.SwapResult_Role", SwapResult_Role_name, SwapResult_Role_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Xud service

type XudClient interface {
	// Add a currency to the list of supported currencies.
	AddCurrency(ctx context.Context, in *AddCurrencyRequest, opts ...grpc.CallOption) (*AddCurrencyResponse, error)
	// Add a trading pair to the list of supported trading pairs.
	AddPair(ctx context.Context, in *AddPairRequest, opts ...grpc.CallOption) (*AddPairResponse, error)
	// Removes an order from the order book by its local id.
	RemoveOrder(ctx context.Context, in *RemoveOrderRequest, opts ...grpc.CallOption) (*RemoveOrderResponse, error)
	// Get the total balance available across all channels for a given currency.
	ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error)
	// Connect to an XU node.
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	// Ban a XU node manually and disconnect from it.
	Ban(ctx context.Context, in *BanRequest, opts ...grpc.CallOption) (*BanResponse, error)
	// Remove ban from XU node manually and connect to it.
	Unban(ctx context.Context, in *UnbanRequest, opts ...grpc.CallOption) (*UnbanResponse, error)
	// Get general information about this Exchange Union node.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// Gets orders from the order book. This call returns the state of the order book at a given point
	// in time, although it is not guaranteed to still be vaild by the time a response is received
	// and processed by a client. It accepts an optional trading pair id parameter. If specified, only
	// orders for that particular trading pair are returned. Otherwise, all orders are returned. Orders
	// are separated into buys and sells for each trading pair, but unsorted.
	GetOrders(ctx context.Context, in *GetOrdersRequest, opts ...grpc.CallOption) (*GetOrdersResponse, error)
	// Get the list of the order book's supported currencies.
	ListCurrencies(ctx context.Context, in *ListCurrenciesRequest, opts ...grpc.CallOption) (*ListCurrenciesResponse, error)
	// Get the list of the order book's suported trading pairs.
	ListPairs(ctx context.Context, in *ListPairsRequest, opts ...grpc.CallOption) (*ListPairsResponse, error)
	// Get a list of connected peers.
	ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error)
	// Add an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (Xud_PlaceOrderClient, error)
	// The synchronous non-streaming version of PlaceOrder.
	PlaceOrderSync(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error)
	// Remove a currency.
	RemoveCurrency(ctx context.Context, in *RemoveCurrencyRequest, opts ...grpc.CallOption) (*RemoveCurrencyResponse, error)
	// Remove a trading pair.
	RemovePair(ctx context.Context, in *RemovePairRequest, opts ...grpc.CallOption) (*RemovePairResponse, error)
	// Begin shutting down xud.
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
	// Subscribes to orders being added to the order book. This call, together with SubscribeRemovedOrders,
	// allows the client to maintain an up-to-date view of the order book. For example, an exchange that
	// wants to show its users a real time list of the orders available to them would subscribe to this
	// streaming call to be alerted of new orders as they become available for trading.
	SubscribeAddedOrders(ctx context.Context, in *SubscribeAddedOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeAddedOrdersClient, error)
	// Subscribes to orders being removed - either in full or in part - from the order book. This call,
	// together with SubscribeAddedOrders, allows the client to maintain an up-to-date view of the order
	// book. For example, an exchange that wants to show its users a real time list of the orders available
	// to them would subscribe to this streaming call to be alerted when part or all of an existing order
	// is no longer available for trading.
	SubscribeRemovedOrders(ctx context.Context, in *SubscribeRemovedOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeRemovedOrdersClient, error)
	// Subscribes to completed swaps that are initiated by a remote peer. This call allows the client to
	// get real-time notifications when its orders are filled by a remote taker. It can be used for
	// tracking order executions, updating balances, and informing a trader when one of their orders
	// is settled through Exchange Union network.
	SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error)
}

type xudClient struct {
	cc *grpc.ClientConn
}

func NewXudClient(cc *grpc.ClientConn) XudClient {
	return &xudClient{cc}
}

func (c *xudClient) AddCurrency(ctx context.Context, in *AddCurrencyRequest, opts ...grpc.CallOption) (*AddCurrencyResponse, error) {
	out := new(AddCurrencyResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/AddCurrency", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) AddPair(ctx context.Context, in *AddPairRequest, opts ...grpc.CallOption) (*AddPairResponse, error) {
	out := new(AddPairResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/AddPair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemoveOrder(ctx context.Context, in *RemoveOrderRequest, opts ...grpc.CallOption) (*RemoveOrderResponse, error) {
	out := new(RemoveOrderResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/RemoveOrder", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error) {
	out := new(ChannelBalanceResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ChannelBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	out := new(ConnectResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Connect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Ban(ctx context.Context, in *BanRequest, opts ...grpc.CallOption) (*BanResponse, error) {
	out := new(BanResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Ban", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Unban(ctx context.Context, in *UnbanRequest, opts ...grpc.CallOption) (*UnbanResponse, error) {
	out := new(UnbanResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Unban", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/GetInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetOrders(ctx context.Context, in *GetOrdersRequest, opts ...grpc.CallOption) (*GetOrdersResponse, error) {
	out := new(GetOrdersResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/GetOrders", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListCurrencies(ctx context.Context, in *ListCurrenciesRequest, opts ...grpc.CallOption) (*ListCurrenciesResponse, error) {
	out := new(ListCurrenciesResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListCurrencies", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListPairs(ctx context.Context, in *ListPairsRequest, opts ...grpc.CallOption) (*ListPairsResponse, error) {
	out := new(ListPairsResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListPairs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error) {
	out := new(ListPeersResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (Xud_PlaceOrderClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[0], c.cc, "/xudrpc.Xud/PlaceOrder", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudPlaceOrderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_PlaceOrderClient interface {
	Recv() (*PlaceOrderEvent, error)
	grpc.ClientStream
}

type xudPlaceOrderClient struct {
	grpc.ClientStream
}

func (x *xudPlaceOrderClient) Recv() (*PlaceOrderEvent, error) {
	m := new(PlaceOrderEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) PlaceOrderSync(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error) {
	out := new(PlaceOrderResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/PlaceOrderSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemoveCurrency(ctx context.Context, in *RemoveCurrencyRequest, opts ...grpc.CallOption) (*RemoveCurrencyResponse, error) {
	out := new(RemoveCurrencyResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/RemoveCurrency", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemovePair(ctx context.Context, in *RemovePairRequest, opts ...grpc.CallOption) (*RemovePairResponse, error) {
	out := new(RemovePairResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/RemovePair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	out := new(ShutdownResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Shutdown", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) SubscribeAddedOrders(ctx context.Context, in *SubscribeAddedOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeAddedOrdersClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[1], c.cc, "/xudrpc.Xud/SubscribeAddedOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeAddedOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeAddedOrdersClient interface {
	Recv() (*Order, error)
	grpc.ClientStream
}

type xudSubscribeAddedOrdersClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeAddedOrdersClient) Recv() (*Order, error) {
	m := new(Order)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeRemovedOrders(ctx context.Context, in *SubscribeRemovedOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeRemovedOrdersClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[2], c.cc, "/xudrpc.Xud/SubscribeRemovedOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeRemovedOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeRemovedOrdersClient interface {
	Recv() (*OrderRemoval, error)
	grpc.ClientStream
}

type xudSubscribeRemovedOrdersClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeRemovedOrdersClient) Recv() (*OrderRemoval, error) {
	m := new(OrderRemoval)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[3], c.cc, "/xudrpc.Xud/SubscribeSwaps", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeSwapsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeSwapsClient interface {
	Recv() (*SwapResult, error)
	grpc.ClientStream
}

type xudSubscribeSwapsClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeSwapsClient) Recv() (*SwapResult, error) {
	m := new(SwapResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Xud service

type XudServer interface {
	// Add a currency to the list of supported currencies.
	AddCurrency(context.Context, *AddCurrencyRequest) (*AddCurrencyResponse, error)
	// Add a trading pair to the list of supported trading pairs.
	AddPair(context.Context, *AddPairRequest) (*AddPairResponse, error)
	// Removes an order from the order book by its local id.
	RemoveOrder(context.Context, *RemoveOrderRequest) (*RemoveOrderResponse, error)
	// Get the total balance available across all channels for a given currency.
	ChannelBalance(context.Context, *ChannelBalanceRequest) (*ChannelBalanceResponse, error)
	// Connect to an XU node.
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	// Ban a XU node manually and disconnect from it.
	Ban(context.Context, *BanRequest) (*BanResponse, error)
	// Remove ban from XU node manually and connect to it.
	Unban(context.Context, *UnbanRequest) (*UnbanResponse, error)
	// Get general information about this Exchange Union node.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// Gets orders from the order book. This call returns the state of the order book at a given point
	// in time, although it is not guaranteed to still be vaild by the time a response is received
	// and processed by a client. It accepts an optional trading pair id parameter. If specified, only
	// orders for that particular trading pair are returned. Otherwise, all orders are returned. Orders
	// are separated into buys and sells for each trading pair, but unsorted.
	GetOrders(context.Context, *GetOrdersRequest) (*GetOrdersResponse, error)
	// Get the list of the order book's supported currencies.
	ListCurrencies(context.Context, *ListCurrenciesRequest) (*ListCurrenciesResponse, error)
	// Get the list of the order book's suported trading pairs.
	ListPairs(context.Context, *ListPairsRequest) (*ListPairsResponse, error)
	// Get a list of connected peers.
	ListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error)
	// Add an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(*PlaceOrderRequest, Xud_PlaceOrderServer) error
	// The synchronous non-streaming version of PlaceOrder.
	PlaceOrderSync(context.Context, *PlaceOrderRequest) (*PlaceOrderResponse, error)
	// Remove a currency.
	RemoveCurrency(context.Context, *RemoveCurrencyRequest) (*RemoveCurrencyResponse, error)
	// Remove a trading pair.
	RemovePair(context.Context, *RemovePairRequest) (*RemovePairResponse, error)
	// Begin shutting down xud.
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
	// Subscribes to orders being added to the order book. This call, together with SubscribeRemovedOrders,
	// allows the client to maintain an up-to-date view of the order book. For example, an exchange that
	// wants to show its users a real time list of the orders available to them would subscribe to this
	// streaming call to be alerted of new orders as they become available for trading.
	SubscribeAddedOrders(*SubscribeAddedOrdersRequest, Xud_SubscribeAddedOrdersServer) error
	// Subscribes to orders being removed - either in full or in part - from the order book. This call,
	// together with SubscribeAddedOrders, allows the client to maintain an up-to-date view of the order
	// book. For example, an exchange that wants to show its users a real time list of the orders available
	// to them would subscribe to this streaming call to be alerted when part or all of an existing order
	// is no longer available for trading.
	SubscribeRemovedOrders(*SubscribeRemovedOrdersRequest, Xud_SubscribeRemovedOrdersServer) error
	// Subscribes to completed swaps that are initiated by a remote peer. This call allows the client to
	// get real-time notifications when its orders are filled by a remote taker. It can be used for
	// tracking order executions, updating balances, and informing a trader when one of their orders
	// is settled through Exchange Union network.
	SubscribeSwaps(*SubscribeSwapsRequest, Xud_SubscribeSwapsServer) error
}

func RegisterXudServer(s *grpc.Server, srv XudServer) {
	s.RegisterService(&_Xud_serviceDesc, srv)
}

func _Xud_AddCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCurrencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).AddCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/AddCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).AddCurrency(ctx, req.(*AddCurrencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_AddPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).AddPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/AddPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).AddPair(ctx, req.(*AddPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemoveOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemoveOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemoveOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemoveOrder(ctx, req.(*RemoveOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ChannelBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ChannelBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ChannelBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ChannelBalance(ctx, req.(*ChannelBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Ban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Ban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Ban",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Ban(ctx, req.(*BanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Unban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Unban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Unban",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Unban(ctx, req.(*UnbanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetOrders(ctx, req.(*GetOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCurrenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListCurrencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListCurrencies(ctx, req.(*ListCurrenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPairsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListPairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListPairs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListPairs(ctx, req.(*ListPairsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListPeers(ctx, req.(*ListPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_PlaceOrder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PlaceOrderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).PlaceOrder(m, &xudPlaceOrderServer{stream})
}

type Xud_PlaceOrderServer interface {
	Send(*PlaceOrderEvent) error
	grpc.ServerStream
}

type xudPlaceOrderServer struct {
	grpc.ServerStream
}

func (x *xudPlaceOrderServer) Send(m *PlaceOrderEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_PlaceOrderSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaceOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).PlaceOrderSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/PlaceOrderSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).PlaceOrderSync(ctx, req.(*PlaceOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemoveCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCurrencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemoveCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemoveCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemoveCurrency(ctx, req.(*RemoveCurrencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemovePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemovePair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemovePair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemovePair(ctx, req.(*RemovePairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_SubscribeAddedOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeAddedOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeAddedOrders(m, &xudSubscribeAddedOrdersServer{stream})
}

type Xud_SubscribeAddedOrdersServer interface {
	Send(*Order) error
	grpc.ServerStream
}

type xudSubscribeAddedOrdersServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeAddedOrdersServer) Send(m *Order) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeRemovedOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRemovedOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeRemovedOrders(m, &xudSubscribeRemovedOrdersServer{stream})
}

type Xud_SubscribeRemovedOrdersServer interface {
	Send(*OrderRemoval) error
	grpc.ServerStream
}

type xudSubscribeRemovedOrdersServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeRemovedOrdersServer) Send(m *OrderRemoval) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeSwaps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeSwaps(m, &xudSubscribeSwapsServer{stream})
}

type Xud_SubscribeSwapsServer interface {
	Send(*SwapResult) error
	grpc.ServerStream
}

type xudSubscribeSwapsServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeSwapsServer) Send(m *SwapResult) error {
	return x.ServerStream.SendMsg(m)
}

var _Xud_serviceDesc = grpc.ServiceDesc{
	ServiceName: "xudrpc.Xud",
	HandlerType: (*XudServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCurrency",
			Handler:    _Xud_AddCurrency_Handler,
		},
		{
			MethodName: "AddPair",
			Handler:    _Xud_AddPair_Handler,
		},
		{
			MethodName: "RemoveOrder",
			Handler:    _Xud_RemoveOrder_Handler,
		},
		{
			MethodName: "ChannelBalance",
			Handler:    _Xud_ChannelBalance_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _Xud_Connect_Handler,
		},
		{
			MethodName: "Ban",
			Handler:    _Xud_Ban_Handler,
		},
		{
			MethodName: "Unban",
			Handler:    _Xud_Unban_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _Xud_GetInfo_Handler,
		},
		{
			MethodName: "GetOrders",
			Handler:    _Xud_GetOrders_Handler,
		},
		{
			MethodName: "ListCurrencies",
			Handler:    _Xud_ListCurrencies_Handler,
		},
		{
			MethodName: "ListPairs",
			Handler:    _Xud_ListPairs_Handler,
		},
		{
			MethodName: "ListPeers",
			Handler:    _Xud_ListPeers_Handler,
		},
		{
			MethodName: "PlaceOrderSync",
			Handler:    _Xud_PlaceOrderSync_Handler,
		},
		{
			MethodName: "RemoveCurrency",
			Handler:    _Xud_RemoveCurrency_Handler,
		},
		{
			MethodName: "RemovePair",
			Handler:    _Xud_RemovePair_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _Xud_Shutdown_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PlaceOrder",
			Handler:       _Xud_PlaceOrder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeAddedOrders",
			Handler:       _Xud_SubscribeAddedOrders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeRemovedOrders",
			Handler:       _Xud_SubscribeRemovedOrders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeSwaps",
			Handler:       _Xud_SubscribeSwaps_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "xudrpc.proto",
}

func init() { proto.RegisterFile("xudrpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2147 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0x4b, 0x73, 0x1c, 0x49,
	0x11, 0x56, 0xcf, 0x7b, 0x72, 0xa4, 0xd1, 0x4c, 0xe9, 0x35, 0x1e, 0x3f, 0x30, 0x85, 0x0d, 0xc2,
	0xeb, 0x95, 0x8c, 0x1c, 0xb1, 0xde, 0xdd, 0x08, 0x0e, 0x92, 0x56, 0xd8, 0x06, 0xb1, 0x38, 0x4a,
	0xbb, 0x04, 0x04, 0xb0, 0x1d, 0x3d, 0xdd, 0xb5, 0x52, 0x87, 0x5b, 0xd5, 0xe3, 0x7e, 0x48, 0xab,
	0x2b, 0x7f, 0x81, 0x0b, 0x17, 0x22, 0x80, 0xff, 0xc0, 0x9d, 0x13, 0x07, 0x82, 0xe0, 0xc2, 0x95,
	0x23, 0x27, 0x7e, 0x05, 0x51, 0xaf, 0xee, 0xaa, 0x9e, 0x1e, 0xe3, 0x8d, 0xd8, 0xdb, 0x54, 0x56,
	0xd6, 0x97, 0x59, 0x59, 0xf9, 0xec, 0x81, 0xd5, 0xaf, 0xf2, 0x20, 0x99, 0xfb, 0x7b, 0xf3, 0x24,
	0xce, 0x62, 0xd4, 0x91, 0xab, 0xe9, 0x9d, 0xf3, 0x38, 0x3e, 0x8f, 0xe8, 0xbe, 0x37, 0x0f, 0xf7,
	0x3d, 0xc6, 0xe2, 0xcc, 0xcb, 0xc2, 0x98, 0xa5, 0x92, 0x0b, 0xff, 0xd7, 0x01, 0x74, 0x18, 0x04,
	0xc7, 0x79, 0x92, 0x50, 0xe6, 0xdf, 0x10, 0xfa, 0x26, 0xa7, 0x69, 0x86, 0xa6, 0xd0, 0xf3, 0x15,
	0x69, 0xe2, 0xdc, 0x77, 0x76, 0xfb, 0xa4, 0x58, 0xa3, 0xe7, 0x30, 0x48, 0xaf, 0xbd, 0xb9, 0xeb,
	0x47, 0x21, 0x65, 0xd9, 0xa4, 0x71, 0xdf, 0xd9, 0x1d, 0x1e, 0x3c, 0xdc, 0x53, 0xc2, 0x17, 0xc1,
	0xf6, 0xce, 0xae, 0xbd, 0xf9, 0xb1, 0x60, 0x26, 0xe6, 0x49, 0xf4, 0x00, 0xd6, 0xb2, 0xf8, 0x35,
	0x65, 0xae, 0x17, 0x04, 0x09, 0x4d, 0xd3, 0x49, 0x53, 0x48, 0xb2, 0x89, 0xe8, 0xbb, 0x30, 0x0c,
	0xa8, 0x1f, 0x5e, 0x7a, 0x91, 0x3b, 0x8f, 0x3c, 0x9f, 0xa6, 0x93, 0xd6, 0x7d, 0x67, 0x77, 0x8d,
	0x54, 0xa8, 0xf8, 0xdb, 0x00, 0xa5, 0x20, 0xd4, 0x85, 0xe6, 0xe9, 0xa7, 0x9f, 0x8c, 0x56, 0x10,
	0x40, 0x87, 0x1c, 0xbe, 0xfc, 0xe4, 0xe4, 0xd3, 0x91, 0x83, 0xb7, 0x60, 0xc3, 0x52, 0x2f, 0x9d,
	0xc7, 0x2c, 0xa5, 0xf8, 0x0b, 0x18, 0x1e, 0x06, 0xc1, 0x2b, 0x2f, 0x4c, 0xf4, 0xf5, 0x1f, 0xc0,
	0xda, 0xcc, 0x4b, 0xa9, 0x5b, 0xb1, 0x81, 0x4d, 0xe4, 0x9a, 0xbd, 0xc9, 0xe3, 0xcc, 0x60, 0x6b,
	0x08, 0xb6, 0x0a, 0x15, 0x8f, 0x61, 0xbd, 0xc0, 0x57, 0x22, 0x9f, 0x00, 0x22, 0xf4, 0x32, 0xbe,
	0xa2, 0x3f, 0x4b, 0x02, 0x9a, 0x18, 0x56, 0x8f, 0xf9, 0xda, 0x0d, 0x03, 0x6d, 0x75, 0xbd, 0xe6,
	0xba, 0x5b, 0x27, 0x4a, 0xdd, 0x8f, 0x2f, 0x3c, 0xc6, 0x68, 0x74, 0xe4, 0x45, 0x1e, 0xf3, 0x29,
	0x9a, 0x40, 0x77, 0x26, 0x7f, 0x0a, 0x8c, 0x26, 0xd1, 0x4b, 0x74, 0x00, 0x9b, 0x73, 0xca, 0x82,
	0x90, 0x9d, 0xbb, 0xf1, 0x9c, 0x32, 0x57, 0xb3, 0x35, 0x04, 0x5b, 0xed, 0x1e, 0x7e, 0x0a, 0x5b,
	0x36, 0xfe, 0x3b, 0x78, 0x08, 0xfe, 0x8b, 0x03, 0xdb, 0xd5, 0x53, 0x52, 0x5f, 0xf4, 0x23, 0xe8,
	0x29, 0xe8, 0x74, 0xe2, 0xdc, 0x6f, 0xee, 0x0e, 0x0e, 0x1e, 0x6b, 0xcf, 0xa9, 0x3f, 0xb1, 0xa7,
	0xd6, 0xe9, 0x09, 0xcb, 0x92, 0x1b, 0xd2, 0x11, 0x06, 0x49, 0xa7, 0x67, 0xb0, 0x66, 0x6d, 0xa0,
	0x11, 0x34, 0x5f, 0x53, 0xad, 0x0a, 0xff, 0x89, 0x1e, 0x43, 0xfb, 0xca, 0x8b, 0x72, 0x79, 0xbf,
	0xc1, 0xc1, 0xf6, 0x12, 0x39, 0x92, 0xe9, 0xe3, 0xc6, 0x87, 0x0e, 0x7e, 0x0c, 0xc3, 0xe3, 0x98,
	0x31, 0xea, 0x67, 0xc6, 0x2d, 0x59, 0x1c, 0x50, 0x37, 0x4f, 0x42, 0x7d, 0x4b, 0xbd, 0xe6, 0xcf,
	0x5a, 0x70, 0x17, 0xcf, 0x0a, 0x47, 0x1e, 0xd3, 0x87, 0x31, 0xac, 0x0a, 0xe6, 0x79, 0x3e, 0x73,
	0x4b, 0xdd, 0x2c, 0x1a, 0x5e, 0x83, 0x81, 0x38, 0xa1, 0x00, 0x46, 0x30, 0x7c, 0x4e, 0xb3, 0x97,
	0xec, 0xcb, 0x58, 0x81, 0xe0, 0xbf, 0x37, 0x60, 0xbd, 0x20, 0x29, 0x23, 0x4e, 0xa0, 0x7b, 0x45,
	0x93, 0x34, 0x8c, 0x99, 0xc2, 0xd4, 0xcb, 0x05, 0x91, 0x8d, 0x45, 0x91, 0x08, 0x41, 0x2b, 0x4f,
	0x42, 0x1e, 0x6d, 0xcd, 0xdd, 0x3e, 0x11, 0xbf, 0xd1, 0x1d, 0xe8, 0xb3, 0xfc, 0xd2, 0x9d, 0x53,
	0x9a, 0xc8, 0xf8, 0x6a, 0x93, 0x92, 0x50, 0xec, 0x7a, 0x61, 0x92, 0x4e, 0xda, 0xc6, 0x2e, 0x27,
	0xa0, 0xf7, 0x40, 0x3d, 0xca, 0xa4, 0x23, 0x0c, 0xbd, 0xa1, 0x0d, 0x2d, 0x3c, 0x35, 0x3d, 0x8e,
	0x73, 0x96, 0xe9, 0x77, 0x43, 0xdf, 0x83, 0x4e, 0xc4, 0x82, 0x59, 0xe6, 0x4f, 0xba, 0x82, 0x79,
	0x5d, 0x33, 0x9f, 0xb2, 0x40, 0xdc, 0x51, 0x6d, 0x2b, 0xc6, 0x28, 0xf3, 0x27, 0xbd, 0xe5, 0x8c,
	0x51, 0xe6, 0xa3, 0x47, 0xd0, 0x49, 0xbc, 0x30, 0xa0, 0x6c, 0xd2, 0x17, 0x8c, 0x48, 0x33, 0x12,
	0x41, 0x95, 0xbc, 0x92, 0x03, 0xff, 0x1a, 0x46, 0xcf, 0x69, 0x26, 0xf5, 0xd2, 0xaf, 0x34, 0x81,
	0x2e, 0xbf, 0x47, 0x19, 0x73, 0x7a, 0x89, 0xf6, 0x00, 0x85, 0xcc, 0x8f, 0xf2, 0x80, 0xba, 0xf1,
	0x35, 0x73, 0xd5, 0x25, 0xb9, 0x49, 0x7b, 0xa4, 0x66, 0x07, 0xff, 0xc1, 0x81, 0xb1, 0x01, 0xaf,
	0x1e, 0xeb, 0x87, 0x85, 0x79, 0xa4, 0xbf, 0x17, 0x99, 0x72, 0x81, 0x55, 0x19, 0xcc, 0x76, 0xf4,
	0x97, 0x30, 0x30, 0xc8, 0x35, 0x6e, 0xfe, 0xc0, 0x76, 0xf3, 0xa1, 0x6d, 0x7d, 0xd3, 0xbd, 0x77,
	0x60, 0xeb, 0x34, 0x4c, 0x33, 0x95, 0xff, 0x42, 0xaa, 0x4d, 0x80, 0x3f, 0x84, 0xed, 0xea, 0x86,
	0x52, 0xfe, 0x1e, 0x80, 0x5f, 0x50, 0xc5, 0x05, 0xfa, 0xc4, 0xa0, 0x60, 0x04, 0x23, 0x7e, 0x92,
	0xe7, 0xb6, 0x02, 0xed, 0xfb, 0x30, 0x36, 0x68, 0x0a, 0x68, 0x13, 0xda, 0xd2, 0x7d, 0x24, 0x86,
	0x5c, 0x14, 0xc7, 0x69, 0xf9, 0x1e, 0xf8, 0x99, 0x3a, 0x4e, 0x4d, 0x23, 0x62, 0x68, 0x4b, 0xdf,
	0x94, 0x36, 0x5c, 0xd5, 0x97, 0xe4, 0x5c, 0x44, 0x6e, 0xe1, 0x5f, 0xc1, 0xe0, 0x94, 0x05, 0x2a,
	0xba, 0x53, 0xb4, 0x0d, 0x1d, 0xcf, 0xcf, 0xc2, 0x2b, 0x99, 0x06, 0xdb, 0x44, 0xad, 0x78, 0x48,
	0x87, 0x4c, 0xed, 0x34, 0xc4, 0x4e, 0xb1, 0x16, 0xbe, 0x20, 0xb3, 0xa0, 0xa8, 0x45, 0x6d, 0xa2,
	0x97, 0xf8, 0x9f, 0x0e, 0x74, 0x95, 0xe7, 0xf1, 0xbb, 0xd0, 0x24, 0x89, 0x13, 0xf5, 0x0a, 0x72,
	0x81, 0xf6, 0xa1, 0xe7, 0x2b, 0xd9, 0xea, 0x29, 0x36, 0x0c, 0x97, 0xd5, 0x6a, 0x91, 0x82, 0x89,
	0x2b, 0xe8, 0x5f, 0x78, 0x21, 0xd3, 0x91, 0xa8, 0x56, 0xe8, 0x3e, 0x0c, 0x66, 0x51, 0xec, 0xbf,
	0xbe, 0xa0, 0xe1, 0xf9, 0x45, 0xa6, 0xa2, 0xd1, 0x24, 0x15, 0x11, 0xdc, 0x36, 0x22, 0xd8, 0xc8,
	0x09, 0x1d, 0x3b, 0x27, 0x6c, 0x42, 0xdb, 0x8b, 0x42, 0x2f, 0x15, 0x11, 0xd7, 0x27, 0x72, 0x81,
	0xff, 0xd4, 0x80, 0xb6, 0x70, 0x11, 0xf1, 0x34, 0x49, 0xa8, 0xca, 0x85, 0x43, 0xe4, 0x82, 0x9b,
	0xe9, 0x4d, 0xee, 0xb1, 0x2c, 0xcc, 0x64, 0x16, 0x71, 0x48, 0xb1, 0x36, 0x43, 0xa6, 0x69, 0x87,
	0xcc, 0x10, 0x1a, 0x61, 0x20, 0x54, 0xee, 0x93, 0x46, 0x18, 0xa0, 0x07, 0xb0, 0xca, 0x1f, 0xa7,
	0xc8, 0x47, 0x3c, 0x79, 0xf4, 0x5f, 0xac, 0x10, 0x8b, 0x8a, 0xee, 0x40, 0x2f, 0x8a, 0x7d, 0x2f,
	0xe2, 0x80, 0x1d, 0xc5, 0x51, 0x50, 0x84, 0x0f, 0x26, 0xd4, 0xcb, 0x68, 0xe0, 0x7a, 0x99, 0xb8,
	0x44, 0x93, 0x18, 0x14, 0xf4, 0x10, 0x5a, 0x69, 0x18, 0x50, 0x91, 0x27, 0x86, 0x07, 0x63, 0xcb,
	0xff, 0xcf, 0xc2, 0x80, 0x12, 0xb1, 0xcd, 0x53, 0x63, 0x98, 0x96, 0xe1, 0x2a, 0xb2, 0x45, 0x8f,
	0x58, 0xb4, 0xa3, 0x35, 0x18, 0xc8, 0x85, 0x48, 0x7c, 0xf8, 0x8f, 0x0e, 0xac, 0xaa, 0x72, 0x7b,
	0x19, 0x5f, 0x79, 0x91, 0x65, 0x14, 0x67, 0xb9, 0x51, 0x1a, 0xb6, 0x51, 0xcc, 0xb2, 0xde, 0xb4,
	0xcb, 0x3a, 0xdf, 0x2b, 0xae, 0x2e, 0xcd, 0x56, 0x5e, 0xbc, 0xaa, 0x71, 0x7b, 0x51, 0x63, 0x7c,
	0x01, 0x1d, 0x19, 0xe8, 0xe8, 0x7d, 0x80, 0x59, 0x7e, 0xe3, 0x5a, 0xb9, 0x66, 0xcd, 0x32, 0x06,
	0x31, 0x18, 0xd0, 0x3e, 0x0c, 0x52, 0x1a, 0x45, 0x65, 0x56, 0xab, 0xe1, 0x37, 0x39, 0xf0, 0x53,
	0x9d, 0x88, 0x44, 0x42, 0xe7, 0x3e, 0xc8, 0x6d, 0xa4, 0x82, 0x4b, 0xfc, 0xe6, 0xc9, 0x29, 0xbe,
	0x66, 0x2a, 0xaa, 0xf8, 0x4f, 0xfc, 0xfb, 0x06, 0xb4, 0x78, 0x8c, 0x72, 0xeb, 0xe8, 0x2e, 0x4f,
	0x65, 0x59, 0xdd, 0xdf, 0xbd, 0x4b, 0xc9, 0xda, 0x85, 0xf5, 0x88, 0x05, 0xee, 0x2c, 0xf3, 0x0b,
	0x36, 0x69, 0xc8, 0x2a, 0x59, 0x73, 0x46, 0x06, 0x67, 0xab, 0xe4, 0x34, 0xc8, 0x5c, 0xa3, 0x90,
	0xcd, 0xe2, 0x9c, 0x05, 0xca, 0xb0, 0x7a, 0x59, 0xe6, 0xaa, 0x8e, 0x91, 0xab, 0x78, 0x58, 0x7e,
	0x95, 0x07, 0xae, 0x0e, 0x32, 0x19, 0x4c, 0x26, 0x09, 0x3d, 0x86, 0x71, 0x4a, 0xfd, 0x98, 0x05,
	0xa9, 0xeb, 0xcb, 0xc6, 0x80, 0x06, 0xc2, 0x2b, 0xdb, 0x64, 0x71, 0x03, 0xff, 0xd9, 0x81, 0xf1,
	0x2b, 0xde, 0xba, 0x5a, 0x2d, 0xe0, 0x37, 0x19, 0x8c, 0xa6, 0xdf, 0xb5, 0x2a, 0x7e, 0xa7, 0x83,
	0xa6, 0xfd, 0xd6, 0xa0, 0xc1, 0x7f, 0x75, 0x00, 0x99, 0x4a, 0xaa, 0x74, 0xfc, 0x11, 0x8c, 0x42,
	0x96, 0xd1, 0x84, 0x79, 0x91, 0x7b, 0xe9, 0x65, 0xfe, 0x05, 0x5d, 0xe2, 0x71, 0x0b, 0x6c, 0xe8,
	0x03, 0x58, 0x15, 0x33, 0x40, 0x42, 0xd3, 0x3c, 0xca, 0xb4, 0xe3, 0x15, 0x45, 0x9b, 0xb7, 0xf0,
	0x44, 0x6c, 0x11, 0x8b, 0x0f, 0x3d, 0x83, 0xf5, 0x84, 0x5e, 0x7a, 0x21, 0x13, 0x2d, 0xaa, 0x88,
	0x87, 0xa6, 0xc8, 0xb2, 0x15, 0x89, 0x55, 0x2e, 0xfc, 0x37, 0x07, 0xd6, 0xcb, 0x2b, 0x9c, 0x5c,
	0xf1, 0xe9, 0xe0, 0x19, 0x0c, 0x6d, 0xc5, 0x84, 0xb9, 0xab, 0x58, 0x2f, 0x56, 0x48, 0x85, 0x0d,
	0x7d, 0xa0, 0x66, 0x1f, 0xa9, 0x95, 0xca, 0xf3, 0x35, 0xca, 0xbf, 0x58, 0x21, 0x26, 0x23, 0xfa,
	0xe8, 0xdd, 0xb4, 0x7f, 0xb1, 0xb2, 0xa0, 0xff, 0x51, 0x17, 0xda, 0x94, 0x2b, 0x8d, 0x13, 0x80,
	0xb2, 0xa5, 0x59, 0x52, 0x84, 0x8c, 0x30, 0x6b, 0xd8, 0x61, 0x36, 0x35, 0xca, 0x93, 0xac, 0x6d,
	0x65, 0x25, 0x32, 0x6a, 0x47, 0xcb, 0xaa, 0x1d, 0xbc, 0xfd, 0x97, 0x53, 0xc7, 0xd7, 0x18, 0x10,
	0xf1, 0x04, 0xb6, 0xab, 0x87, 0x54, 0x7b, 0xfb, 0x3e, 0x8c, 0xe5, 0x8e, 0x39, 0x6c, 0x2d, 0x6d,
	0xc0, 0xf0, 0xa6, 0x9e, 0x92, 0xac, 0xd9, 0x69, 0x0c, 0xeb, 0x67, 0x17, 0x79, 0x16, 0xc4, 0xd7,
	0xba, 0xd3, 0xe6, 0x7d, 0x44, 0x49, 0x52, 0x6c, 0x77, 0xe1, 0xf6, 0x59, 0x3e, 0x4b, 0xfd, 0x24,
	0x9c, 0xd1, 0xc3, 0x20, 0xa0, 0x81, 0xd5, 0xf6, 0xe1, 0x6f, 0xc1, 0xdd, 0x62, 0x5b, 0x0a, 0xa9,
	0x30, 0xec, 0xc0, 0x56, 0xc1, 0xc0, 0x1f, 0xb6, 0xd8, 0xf8, 0x47, 0x43, 0x4e, 0x9a, 0xf2, 0xa5,
	0xd1, 0xad, 0x85, 0xa1, 0xad, 0x2b, 0xd6, 0x2f, 0xed, 0xe4, 0xde, 0xa8, 0x24, 0xf7, 0xb7, 0x86,
	0x6d, 0x11, 0xec, 0xad, 0x4a, 0xb0, 0x6f, 0x43, 0x27, 0x71, 0x2f, 0xbc, 0xf4, 0x42, 0x56, 0x52,
	0xa2, 0x56, 0x3c, 0xed, 0x79, 0x97, 0x3c, 0x2f, 0xbb, 0x09, 0xf5, 0x69, 0x78, 0x45, 0x65, 0x21,
	0x6d, 0x92, 0x2a, 0x99, 0xa7, 0x31, 0x45, 0x4a, 0xf9, 0xf4, 0x2e, 0xcb, 0xa9, 0x49, 0xe2, 0x09,
	0xd9, 0xaa, 0xd9, 0x3d, 0x99, 0x90, 0xad, 0x8a, 0xfd, 0x1e, 0xb4, 0x92, 0x38, 0xa2, 0xa2, 0x88,
	0x0e, 0x0f, 0x76, 0x16, 0x03, 0x60, 0x8f, 0xc4, 0x11, 0x25, 0x82, 0x09, 0xdf, 0x81, 0x16, 0x5f,
	0xa1, 0x3e, 0xb4, 0x3f, 0x3b, 0xfc, 0xc9, 0x09, 0x19, 0xad, 0xf0, 0x9f, 0x3f, 0x15, 0x3f, 0x1d,
	0xfc, 0x0a, 0x56, 0x3f, 0x67, 0xb3, 0xaf, 0x35, 0x35, 0xf1, 0x81, 0x24, 0xa1, 0x2a, 0x95, 0xaa,
	0x86, 0xbc, 0x24, 0xe0, 0x75, 0x58, 0x53, 0x88, 0xd2, 0x15, 0x1e, 0xdd, 0x83, 0x7e, 0x91, 0xd8,
	0x50, 0x17, 0x9a, 0x47, 0x9f, 0xff, 0x72, 0xb4, 0x82, 0x7a, 0xd0, 0x3a, 0x3b, 0x39, 0x3d, 0x1d,
	0x39, 0x07, 0xff, 0x1e, 0x42, 0xf3, 0x17, 0x79, 0x80, 0x66, 0x30, 0x30, 0xbe, 0x0f, 0xa0, 0xe9,
	0xf2, 0x6f, 0x1a, 0xd3, 0xdb, 0xb5, 0x7b, 0xca, 0xf5, 0xa6, 0xbf, 0xfd, 0xd7, 0x7f, 0x7e, 0xd7,
	0xd8, 0xc4, 0xeb, 0xfb, 0x57, 0x3f, 0xd8, 0xf7, 0x82, 0x40, 0x47, 0xc6, 0xc7, 0xce, 0x23, 0x44,
	0xa0, 0xab, 0x3e, 0x06, 0xa0, 0x6d, 0x03, 0xc3, 0x08, 0x88, 0xe9, 0xce, 0x02, 0x5d, 0xe1, 0x6e,
	0x0b, 0xdc, 0x11, 0x1e, 0x28, 0x5c, 0xee, 0x31, 0x1c, 0x73, 0x06, 0x03, 0xe3, 0xdb, 0x40, 0xa9,
	0xf7, 0xe2, 0x27, 0x86, 0x52, 0xef, 0xba, 0x8f, 0x09, 0x96, 0xde, 0x89, 0x60, 0x10, 0xae, 0xcc,
	0x65, 0xbc, 0x5e, 0xf8, 0xd0, 0x70, 0x77, 0xd9, 0xe0, 0x2e, 0x25, 0xdd, 0x7b, 0xfb, 0x5c, 0xaf,
	0x85, 0x21, 0xc4, 0x85, 0xa9, 0x54, 0xa4, 0xbf, 0x54, 0x10, 0xe8, 0xaa, 0xd1, 0xba, 0x34, 0x92,
	0x3d, 0x99, 0x97, 0x46, 0xaa, 0xce, 0xe0, 0x96, 0x91, 0x94, 0x4b, 0xf0, 0x0b, 0x1c, 0x41, 0xf3,
	0xc8, 0x63, 0xa8, 0x48, 0xd6, 0xe5, 0xa0, 0x3e, 0xdd, 0xb0, 0x68, 0x0a, 0x07, 0x09, 0x9c, 0x55,
	0xdc, 0xe5, 0x38, 0x33, 0x8f, 0x71, 0x8c, 0x1f, 0x43, 0x5b, 0x78, 0x16, 0xda, 0xd4, 0x27, 0x4c,
	0xd7, 0x9d, 0x6e, 0x55, 0xa8, 0x0a, 0x69, 0x53, 0x20, 0x0d, 0x71, 0x9f, 0x23, 0xe5, 0x4c, 0x61,
	0x9d, 0x42, 0x57, 0xcd, 0xf5, 0xe5, 0x1d, 0xed, 0xd9, 0xbf, 0xbc, 0x63, 0xe5, 0x03, 0x00, 0x1e,
	0x09, 0x44, 0x40, 0x3d, 0x8e, 0x18, 0x72, 0x88, 0xcf, 0xa0, 0x5f, 0xcc, 0x93, 0x68, 0x52, 0x33,
	0x62, 0x4a, 0xc4, 0x5b, 0x4b, 0x87, 0x4f, 0x7d, 0x5f, 0x04, 0x1c, 0x53, 0x35, 0x89, 0xe7, 0x30,
	0xb4, 0x07, 0xc3, 0xf2, 0xd1, 0x6b, 0x27, 0xc9, 0xf2, 0xd1, 0xeb, 0xe7, 0x49, 0xfd, 0x38, 0x68,
	0x28, 0x1e, 0xa7, 0x84, 0x3d, 0x83, 0x7e, 0x31, 0x33, 0x96, 0xea, 0x57, 0x47, 0xcb, 0x52, 0xfd,
	0x85, 0x01, 0x13, 0x8f, 0x05, 0xf2, 0x00, 0x09, 0x23, 0xcb, 0x8e, 0x4d, 0x83, 0x52, 0xba, 0x00,
	0x4a, 0xe9, 0x32, 0x50, 0x73, 0xec, 0xac, 0x80, 0x0a, 0x9c, 0xdf, 0x00, 0x94, 0xdd, 0x04, 0x2a,
	0xce, 0x2e, 0x74, 0x72, 0xe5, 0xe3, 0x55, 0x9a, 0x0f, 0x7c, 0x4b, 0x80, 0x6e, 0x60, 0x61, 0x03,
	0xf1, 0xf1, 0x52, 0x07, 0xd9, 0x13, 0x07, 0x7d, 0x09, 0xc3, 0x92, 0xff, 0xec, 0x86, 0xf9, 0x6f,
	0x13, 0x31, 0xad, 0xdb, 0xd2, 0xe5, 0x4f, 0x48, 0xd9, 0xc1, 0xc8, 0x96, 0x92, 0xde, 0x30, 0x9f,
	0x7b, 0x1f, 0x83, 0xa1, 0x5d, 0xa3, 0xcb, 0x97, 0xad, 0x2d, 0xf8, 0xe5, 0xcb, 0x2e, 0x29, 0xed,
	0x96, 0x3c, 0x99, 0x3b, 0xcc, 0xb4, 0xf7, 0x05, 0x40, 0x59, 0xca, 0xcb, 0x3b, 0x2d, 0x74, 0x03,
	0xd3, 0x69, 0xdd, 0x96, 0x92, 0x61, 0x59, 0x4e, 0xca, 0xd0, 0x29, 0xf0, 0xe7, 0xd0, 0xd3, 0x1d,
	0x00, 0x2a, 0xcb, 0x91, 0xdd, 0x26, 0x4c, 0x27, 0x8b, 0x1b, 0x0a, 0x79, 0x47, 0x20, 0x8f, 0xf1,
	0x2a, 0x47, 0x4e, 0xd5, 0x2e, 0xc7, 0x0d, 0x61, 0xb3, 0xae, 0x8b, 0x40, 0xdf, 0x29, 0xa0, 0x96,
	0xf7, 0x18, 0x53, 0xbb, 0xb9, 0xc3, 0xb7, 0x85, 0x90, 0x2d, 0xb4, 0x21, 0x84, 0xe8, 0x73, 0xf2,
	0x59, 0x9e, 0x38, 0x28, 0x83, 0xed, 0xfa, 0x8e, 0x04, 0x3d, 0x5c, 0x10, 0x56, 0xd7, 0xb1, 0x4c,
	0x37, 0xed, 0x4e, 0x58, 0xce, 0xac, 0xff, 0x4f, 0xaa, 0x07, 0x43, 0xbb, 0xcd, 0x29, 0x1d, 0xa1,
	0xb6, 0xfd, 0x99, 0xd6, 0x74, 0xbb, 0x76, 0x2e, 0x2f, 0x64, 0xf0, 0x06, 0x38, 0x7d, 0xe2, 0xcc,
	0x3a, 0xe2, 0xaf, 0x86, 0xa7, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xdd, 0xde, 0xa5, 0xa4, 0xa0,
	0x18, 0x00, 0x00,
}
